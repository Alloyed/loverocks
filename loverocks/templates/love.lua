-- This is automatically generated using
-- templates/compile_templates.lua on Thu Sep 14 00:26:06 2017
-- luacheck: push ignore
local _={}
_[1]={["init.lua"]="--- Injects a loverocks-compatible module loader into your game.\n--  See http://github.com/Alloyed/loverocks for details\n--  (c) Kyle McLamb, 2016 <alloyed@tfwno.gf>, MIT License.\n<%- rocks_warning %>\n--  |version: <%- loverocks_version %>|\n\nlocal rocks_tree = (...)\n\nlocal rocks = {}\n\nrocks.paths = {\n\9rocks_tree .. \"/share/lua/5.1/?.lua\",\n\9rocks_tree .. \"/share/lua/5.1/?/init.lua\",\n}\n\nrocks.cpaths = {\n\9rocks_tree .. \"/lib/lua/5.1/?\"\n}\n\n---\n-- Loads loverocks modules.\nfunction rocks.loader(modname)\n\9local modpath = modname:gsub('%.', '/')\n\9for _, elem in ipairs(rocks.paths) do\n\9\9elem = elem:gsub('%?', modpath)\n\9\9if love.filesystem.isFile(elem) then\n\9\9\9return love.filesystem.load(elem)\n\9\9end\n\9end\n\n\9return \"\\n\\tno module '\" .. modname .. \"' in LOVERocks path.\"\nend\n\nlocal function get_os()\n\9if love.system and love.system.getOS then -- >= 0.9.0\n\9\9return love.system.getOS()\n\9elseif love._os then -- < 0.9.0\n\9\9return love._os\n\9else\n\9\9-- either love.system wasn't loaded or something else happened\n\9\9return nil\n\9end\nend\n\nlocal function can_open(fname)\n\9local f, err = io.open(fname, 'r')\n\9if f == nil then\n\9\9return false\n\9end\n\9f:close()\n\9return true\nend\n\nlocal function c_loader(modname, fn_name)\n\9-- turn periods into underscores, and remove a hyphen-prefix.\n\9-- The rules for this are here:\n\9-- https://www.lua.org/manual/5.1/manual.html#pdf-package.loaders\n\9-- I might have the details wrong, PRs welcome\n\9fn_name = fn_name:gsub(\"%.\", \"_\"):gsub(\"^[^-]*-\", \"\")\n\n\9local os = get_os()\n\9if not os then\n\9\9return \"\\n\\tCannot load native LOVERocks modules, OS not found.\"\n\9end\n\n\9local ext  = os == 'Windows' and \".dll\" or \".so\"\n\9local file = modname:gsub(\"%.\", \"/\") .. ext\n\n\9for _, elem in ipairs(rocks.cpaths) do\n\9\9elem = elem:gsub('%?', file)\n\n\9\9local base = nil\n\9\9if love.filesystem.isFused() then\n\9\9\9base = love.filesystem.getSourceBaseDirectory()\n\9\9\9if can_open(base .. \"/\" ..elem) == false then\n\9\9\9\9base = nil -- actually, file not found\n\9\9\9end\n\9\9elseif love.filesystem.exists(elem) then\n\9\9\9base = love.filesystem.getRealDirectory(elem)\n\9\9end\n\n\9\9if base then\n\9\9\9local path = base .. \"/\" .. elem\n\9\9\9local lib, err1 = package.loadlib(path, \"loveopen_\"..fn_name)\n\9\9\9if lib then return lib end\n\n\9\9\9local err2\n\9\9\9lib, err2 = package.loadlib(path, \"luaopen_\"..fn_name)\n\9\9\9if lib then return lib end\n\n\9\9\9if err1 == err2 then\n\9\9\9\9return \"\\n\\t\"..err1\n\9\9\9else\n\9\9\9\9return \"\\n\\t\"..err1..\"\\n\\t\"..err2\n\9\9\9end\n\9\9end\n\9end\n\n\9return \"\\n\\tno library '\" .. file .. \"' in LOVERocks path.\"\nend\n\n--- \n--  Loads native loverocks libraries. In fused mode, these should be placed in\n--  the same directory as the game binary. In non-fused(source) mode these can\n--  either be placed in the game's saveDirectory or within the game's source if\n--  it is run from a folder. Notably, there is no way to load a library that\n--  is packed into a love file.\nfunction rocks.c_1_loader(modname)\n\9return c_loader(modname, modname)\nend\n\n---\n-- Loads native libraries using the \"all-in-one\" technique supported by vanilla\n-- lua and used by libraries luasec to compile several modules into a\n-- single library. It shares the same path rules as `rocks.c_1_loader`.\nfunction rocks.c_all_loader(modname)\n\9local base_mod = modname:match(\"^.+%.\")\n\9if base_mod then\n\9\9return c_loader(base_mod, modname)\n\9end\nend\n\n---\n-- Installs the LOVERocks package loader if it's not already installed.\n-- @param use_external_deps Set to a truthy value if you would like to continue\n--                          using system-level dependencies in your project.\nfunction rocks.inject(use_external_deps)\n\9if package._loverocks then return rocks end\n\n\9table.insert(package.loaders, rocks.loader)\n\9table.insert(package.loaders, rocks.c_1_loader)\n\9table.insert(package.loaders, rocks.c_all_loader)\n\9package._loverocks = true\n\n\9if not use_external_deps then\n\9\9-- It would be nice to just yoink the native loaders out entirely\n\9\9package.path = \"\"\n\9\9package.cpath = \"\"\n\9end\n\n\9return rocks\nend\n\n---\n-- Attempts to `require` the given module, but will suggest that the user try\n-- manually installing dependencies if they aren't found. This can be useful\n-- for source distribution. Behaves like `require` when in fused mode.\nfunction rocks.require(modname)\n\9if love.filesystem.isFused() then return require(modname) end\n\n\9local ok, err_or_mod = pcall(require, modname)\n\9if not ok then\n\9\9error(string.format([[\n\nDependency not found: %s\nIf you downloaded a source package (a.k.a a \".love\" file),\nyou can try installing the dependencies using LOVERocks:\n\n\9$ loverocks --game <my_game.love> deps\n\nMore info at <https://github.com/Alloyed/loverocks>\n\n%s\n]], modname, err_or_mod))\n\9end\n\n\9return err_or_mod\nend\n\nreturn setmetatable(rocks, {__call = rocks.inject})\n"}
return {rocks=_[1],["conf.lua"]="if love.filesystem then\n\9require 'rocks' ()\nend\n\nfunction love.conf(t)\n\9t.identity = <%- string.format(\"%q\", project_name) %>\n\9t.version = <%- raw_version(versions.love) %>\n\9t.dependencies = {\n\9}\nend\n"}
-- luacheck: pop
