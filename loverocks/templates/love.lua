local _={}
_[1]={["init.lua"]="--- Injects a loverocks-compatible module loader into your game.\n--  See http://github.com/Alloyed/loverocks for details\n--  (c) Kyle McLamb, 2016 <alloyed@tfwno.gf>, MIT License.\n<%- rocks_warning %>\n--  |version: <%- loverocks_version %>|\n\nlocal rocks_tree = (...)\n\nlocal rocks = {}\n\nrocks.paths = {\n	rocks_tree .. \"/share/lua/5.1/?.lua\",\n	rocks_tree .. \"/share/lua/5.1/?/init.lua\",\n}\n\nrocks.cpaths = {\n	rocks_tree .. \"/lib/lua/5.1/?\"\n}\n\n---\n-- Loads loverocks modules.\nfunction rocks.loader(modname)\n	local modpath = modname:gsub('%.', '/')\n	for _, elem in ipairs(rocks.paths) do\n		elem = elem:gsub('%?', modpath)\n		if love.filesystem.isFile(elem) then\n			return love.filesystem.load(elem)\n		end\n	end\n\n	return \"\\n\\tno module '\" .. modname .. \"' in LOVERocks path.\"\nend\n\nlocal function get_os()\n	if love.system and love.system.getOS then -- >= 0.9.0\n		return love.system.getOS()\n	elseif love._os then -- < 0.9.0\n		return love._os\n	else\n		-- either love.system wasn't loaded or something else happened\n		return nil\n	end\nend\n\nlocal function can_open(fname)\n	local f, err = io.open(fname, 'r')\n	if f == nil then\n		return false\n	end\n	f:close()\n	return true\nend\n\nlocal function c_loader(modname, fn_name)\n	local os = get_os()\n	if not os then\n		return \"\\n\\tCannot load native LOVERocks modules, OS not found.\"\n	end\n\n	local ext  = os == 'Windows' and \".dll\" or \".so\"\n	local file = modname:gsub(\"%.\", \"/\") .. ext\n\n	for _, elem in ipairs(rocks.cpaths) do\n		elem = elem:gsub('%?', file)\n\n		local base = nil\n		if love.filesystem.isFused() then\n			base = love.filesystem.getSourceBaseDirectory()\n			if can_open(base .. \"/\" ..elem) == false then\n				base = nil -- actually, file not found\n			end\n		elseif love.filesystem.exists(elem) then\n			base = love.filesystem.getRealDirectory(elem)\n		end\n\n		if base then\n			local path = base .. \"/\" .. elem\n			local lib, err1 = package.loadlib(path, \"loveopen_\"..fn_name)\n			if lib then return lib end\n\n			local err2\n			lib, err2 = package.loadlib(path, \"luaopen_\"..fn_name)\n			if lib then return lib end\n\n			if err1 == err2 then\n				return \"\\n\\t\"..err1\n			else\n				return \"\\n\\t\"..err1..\"\\n\\t\"..err2\n			end\n		end\n	end\n\n	return \"\\n\\tno library '\" .. file .. \"' in LOVERocks path.\"\nend\n\n--- \n--  Loads native loverocks libraries. In fused mode, these should be placed in\n--  the same directory as the game binary. In non-fused(source) mode these can\n--  either be placed in the game's saveDirectory or within the game's source if\n--  it is run from a folder. Notably, there is no way to load a library that\n--  is packed into a love file.\nfunction rocks.c_1_loader(modname)\n	return c_loader(modname, modname:gsub(\"%.\", \"_\"))\nend\n\n---\n-- Loads native libraries using the \"all-in-one\" technique supported by vanilla\n-- lua and used by libraries luasec to compile several modules into a\n-- single library. It shares the same path rules as `rocks.c_1_loader`.\nfunction rocks.c_all_loader(modname)\n	local base_mod = modname:match(\"^.+%.\")\n	if base_mod then\n		return c_loader(base_mod, modname:gsub(\"%.\", \"_\"))\n	end\nend\n\n---\n-- Installs the LOVERocks package loader if it's not already installed.\n-- @param use_external_deps Set to a truthy value if you would like to continue\n--                          using system-level dependencies in your project.\nfunction rocks.inject(use_external_deps)\n	if package._loverocks then return rocks end\n\n	table.insert(package.loaders, rocks.loader)\n	table.insert(package.loaders, rocks.c_1_loader)\n	table.insert(package.loaders, rocks.c_all_loader)\n	package._loverocks = true\n\n	if not external_deps then\n		-- It would be nice to just yoink the native loaders out entirely\n		package.path = \"\"\n		package.cpath = \"\"\n	end\n\n	return rocks\nend\n\n---\n-- Attempts to `require` the given module, but will suggest that the user try\n-- manually installing dependencies if they aren't found. This can be useful\n-- for source distribution. Behaves like `require` when in fused mode.\nfunction rocks.require(modname)\n	if love.filesystem.isFused() then return require(modname) end\n\n	local ok, err_or_mod = pcall(require, modname)\n	if not ok then\n		error(string.format([[\n\nDependency not found: %s\nIf you downloaded a source package (a.k.a a \".love\" file),\nyou can try installing the dependencies using LOVERocks:\n\n	$ loverocks --game <my_game.love> deps\n\nMore info at <https://github.com/Alloyed/loverocks>\n\n%s\n]], modname, err_or_mod))\n	end\n\n	return err_or_mod\nend\n\nreturn setmetatable(rocks, {__call = rocks.inject})\n"}
return {[".gitignore"]="*.rock\n/rocks\n",["conf.lua"]="if love.filesystem then\n	require 'rocks' ()\nend\n\nfunction love.conf(t)\n	t.identity = <%- string.format(\"%q\", project_name) %>\n	t.version = <%- raw_version(versions.love) %>\n	t.dependencies = {\n	}\nend\n",rocks=_[1]}